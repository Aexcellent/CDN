Multiparty Computation from Somewhat Homomorphic Encryption
Ivan Damg˚ard1, Valerio Pastro1, Nigel Smart2, and Sarah Zakarias1
1 Department of Computer Science, Aarhus University 2 Department of Computer Science, Bristol University
Abstract. We propose a general multiparty computation protocol secure against an active adversary corrupting up to n − 1 of the n players. The protocol may be used to compute securely arithmetic circuits over any ﬁnite ﬁeld Fpk . Our protocol consists of a preprocessing phase that is both independent of the function to be computed and of the inputs, and a much more eﬃcient online phase where the actual computation takes place. The online phase is unconditionally secure and has total computational (and communication) complexity linear in n, the number of players, where earlier work was quadratic in n. Moreover, the work done by each player is only a small constant factor larger than what one would need to compute the circuit in the clear. We show this is optimal for computation in large ﬁelds. In practice, for 3 players, a secure 64-bit multiplication can be done in 0.05 ms. Our preprocessing is based on a somewhat homomorphic cryptosystem. We extend a scheme by Brakerski et al., so that we can perform distributed decryption and handle many values in parallel in one ciphertext. The computational complexity of our preprocessing phase is dominated by the public-key operations, we need O(n2/s) operations per secure multiplication where s is a parameter that increases with the security parameter of the cryptosystem. Earlier work in this model needed Ω(n2) operations. In practice, the preprocessing prepares a secure 64-bit multiplication for 3 players in about 13 ms.
1 Introduction
A central problem in theoretical cryptography is that of secure multiparty computation (MPC). In this problem n parties, holding private inputs x1, . . . , xn, wish to compute a given function f (x1, . . . , xn). A protocol for doing this securely should be such that honest players get the correct result and this result is the only new information released, even if some subset of the players is controlled by an adversary.
In the case of dishonest majority, where more than half the players are corrupt, unconditionally secure protocols cannot exist. Under computational assumptions, it was shown in [6] how to construct UC-secure MPC protocols that handle the case where all but one of the parties are actively corrupted. The public-key machinery one needs for this is typically expensive so eﬃcient solutions are hard to design for dishonest majority. Recently, however, a new approach has been proposed making such protocols more practical. This approach

works as follows: one ﬁrst designs a general MPC protocol in the preprocessing model, where access to a “trusted dealer” is assumed. The dealer does not need to know the function to be computed, nor the inputs, he just supplies raw material for the computation before it starts. This allows the “online” protocol to use only cheap information theoretic primitives and hence be eﬃcient. Finally, one implements the trusted dealer by a secure protocol using public-key techniques, this protocol can then be run in a preprocessing phase. The current state of the art in this respect are the protocols in Bendlin et al., Damg˚ard/Orlandi and Nielsen et al. [3, 9, 16]. The “MPC-in-the-head” technique of Ishai et al. [13, 12] has similar overall asymptotic complexity, but larger constants and a less eﬃcient online phase.
Recently, another approach has become possible with the advent of Fully Homomorphic Encryption (FHE) by Gentry [10]. In this approach all parties ﬁrst encrypt their input under the FHE scheme; then they evaluate the desired function on the ciphertexts using the homomorphic properties, and ﬁnally they perform a distributed decryption on the ﬁnal ciphertexts to get the results. The advantage of the FHE-based approach is that interaction is only needed to supply inputs and get output. However, the low bandwidth consumption comes at a price; current FHE schemes are very slow and can only evaluate small circuits, i.e., they actually only provide what is known as somewhat homomorphic encryption (SHE). This can be circumvented in two ways; either by assuming circular security and implementing an expensive bootstrapping operation, or by extending the parameter sizes to enable a “levelled FHE” scheme which can evaluate circuits of large degree (exponential in the number of levels) [4]. The main cost, much like other approaches, is in terms of the number of multiplications in the arithmetic circuit. So whilst theoretically appealing the approach via FHE is not competitive in practice with the traditional MPC approach.
1.1 Contributions of this paper.
Optimal Online Phase. We propose an MPC protocol in the preprocessing model that computes securely an arithmetic circuit C over any ﬁnite ﬁeld Fpk . The protocol is statistically UC-secure against active and adaptive corruption of up to n − 1 of the n players, and we assume synchronous communication and secure point-to-point channels. Measured in elementary operations in Fpk the total amount of work done is O(n · |C| + n3) where |C| is the size of C. All earlier work in this model had complexity Ω(n2 · |C|). A similar improvement applies to the communication complexity and the amount of data one needs to store from the preprocessing. Hence, the work done by each player in the online phase is essentially independent of n. Moreover, it is only a small constant factor larger than what one would need to compute the circuit in the clear. This is the ﬁrst protocol in the preprocessing model with these properties3.
3 With dishonest majority, successful termination cannot be guaranteed, so our protocols simply abort if cheating is detected. We do not, however, identify who cheated, indeed the standard deﬁnition of secure function evaluation does not require this.

Finally, we show a lower bound implying that w.r.t the amount of data

required from the preprocessing, our protocol is optimal up to a constant factor.

We also obtain a similar lower bound on the number of bit operations required,

and hence the computational work done in our protocol is optimal up to poly-

logarithmic factors.

All results mentioned here hold for the case of large ﬁelds, i.e., where the

desired error probability is (1/pk)c, for a small constant c. Note that many

applications of MPC need integer arithmetic, modular reductions, conversion to

binary, etc., which we can emulate by computing in Fp with p large enough to avoid overﬂow. This naturally leads to computing with large ﬁelds. As mentioned,

our protocol works for all ﬁelds, but like earlier work in this model it is less

eﬃcient for small ﬁelds by a factor of essentially

sec log pk

for error probability

2−Θ(sec), see the full version for details.

Obtaining our result requires new ideas compared to [3], which was previously

state of the art and was based on additive secret sharing where each share in a

secret is authenticated using an information theoretic Message Authentication

Code (MAC). Since each player needs to have his own key, each of the n shares

need to be authenticated with n MACs, so this approach is inherently quadratic

in n. Our idea is to authenticate the secret value itself instead of the shares, using

a single global key. This seems to lead to a “chicken and egg” problem since one

cannot check a MAC without knowing the key, but if the key is known, MACs can

be forged. Our solution to this involves secret sharing the key as well, carefully

timing when values are revealed, and various tricks to reduce the amortized cost

of checking a set of MACs.

Eﬃcient use of FHE for MPC. As a conceptual contribution we propose what we believe is “the right” way to use FHE/SHE for computationally eﬃcient MPC, namely to use it for implementing a preprocessing phase. The observation is that since such preprocessing is typically based on the classic circuit randomization technique of Beaver [2], it can be done by evaluating in parallel many small circuits of small multiplicative depth (in fact depth 1 in our case). Thus SHE suﬃces, we do not need bootstrapping, and we can use the SHE SIMD approach of [17] to handle many values in parallel in a single ciphertext.
To capitalize on this idea, we apply the SIMD approach to the cryptosystem from [5] (see also [11] where this technique is also used). To get the best performance, we need to do a non-trivial analysis of the parameter values we can use, and we prove some results on norms of embeddings of a cyclotomic ﬁeld for this purpose. We also design a distributed decryption procedure for our cryptosystem. This protocol is only robust against passive attacks. Nevertheless, this is suﬃcient for the overall protocol to be actively secure. Intuitively, this is because the only damage the adversary can do is to add a known error term to the decryption result obtained. The eﬀect of this for the online protocol is that certain shares of secret values may be incorrect, but this will caught by the
Identiﬁcation of cheaters is possible but we do not know how to do this while maintaining complexity linear in n.

check involving the MACs. Finally we adapt a zero-knowledge proof of plaintext knowledge from [3] for our purpose and in particular we improve the analysis of the soundness guarantees it oﬀers. This inﬂuences the choice of parameters for the cryptosystem and therefore improves overall performance.
An Eﬃcient Preprocessing Protocol. As a result of the above, we obtain a constant-round preprocessing protocol that is UC-secure against active and static corruption of n−1 players assuming the underlying cryptosystem is semantically secure, which follows from the polynomial (PLWE) assumption. UC-security for dishonest majority cannot be obtained without a set-up assumption. In this paper we assume that a key pair for our cryptosystem has been generated and the secret key has been shared among the players.
Whereas previous work in the preprocessing/online model [3, 9] use Ω(n2) public-key operations per secure multiplication, we only need O(n2/s) operations, where s is a number that grows with the security parameter of the SHE scheme (we have s ≈ 12000 in our concrete instantiation for computing in Fp where p ≈ 264). We stress that our adapted scheme is exactly as eﬃcient as the basic version of [5] that does not allow this optimization, so the improvement is indeed “genuine”.
In comparison to the approach mentioned above where one uses FHE throughout the protocol, our combined preprocessing and online phase achieves a result that is incomparable from a theoretical point of view, but much more practical: we need more communication and rounds, but the computational overhead is much smaller – we need O(n2/s · |C|) public key operations compared to O(n · |C|) for the FHE approach, where for realistic values of n and s, we have n2/s n. Furthermore, we only need a low depth SHE which is much more eﬃcient in the ﬁrst place. And ﬁnally, we can push all the work using SHE into a, function independent, preprocessing phase.
Performance in practice. Both the preprocessing and online phase have been implemented and tested for 3 players on up-to-date machines connected on a LAN. The preprocessing takes about 13 ms amortized time to prepare one multiplication in Fp for a 64-bit p, with security level corresponding roughly to 1024 bit RSA and an error probability of 2−40 for the zero-knowledge proofs (the error probability can be lowered to 2−80 by repeating the ZK proofs which will at most double the time). This is 2-3 orders of magnitude faster than preliminary estimates for the most eﬃcient instantiation of [3]. The online phase executes a secure 64-bit multiplication in 0.05 ms amortized time. These rough orders of magnitude, and the ability to deal with a non-trivial number of players, are born out by a recent implementation of the protocols described in this paper [7].
Concurrent Related Work. In recent independent work [15, 1, 11], Meyers at al., Asharov et al. and Gentry et al. also use an FHE scheme for multiparty computation. They follow the pure FHE approach mentioned above, using a threshold decryption protocol tailored to the speciﬁc FHE scheme. They focus primarily on round complexity, while we want to minimize the computational overhead.

We note that in [11], Gentry et al. obtain small overhead by showing a way to

use the FHE SIMD approach for computing any circuit homomorphically. How-

ever, this requires full FHE with bootstrapping (to work on arbitrary circuits)

and does not (currently) lead to a practical protocol.

In [16], Nielsen et al. consider secure computing for Boolean Circuits. Their

online phase is similar to that of [3], while the preprocessing is a clever and very

eﬃcient construction based on Oblivious Transfer. This result is complementary

to ours in the sense that we target computations over large ﬁelds which is good

for some applications whereas for other cases, Boolean Circuits are the most

compact way to express the desired computation. Of course, one could use the

preprocessing from [16] to set up data for our online phase, but current bench-

marks indicate that our approach is faster for large ﬁelds, say of size 64 bits or

more.

We end the introduction by covering some basic notation which will be

used throughout this paper. For a vector x = (x1, . . . , xn) ∈ Rn we denote

by x ∞ := max1≤i≤n |xi|, x 1 := 1≤i≤n |xi| and x 2 :=

|xi|2. We let

(κ) denote an unspeciﬁed negligible function of κ. If S is a set we let x ← S

denote assignment to the variable x with respect to a uniform distribution on

S; we use x ← s for a value s as shorthand for x ← {s}. If A is an algorithm

x ← A means assign to x the output of A, where the probability distribution is

over the random coins of A. Finally x := y means “x is deﬁned to be y”.

2 Online Protocol
Our aim is to construct a protocol for arithmetic multiparty computation over Fpk for some prime p. More precisely, we wish to implement the ideal functionality FAMPC, presented in . Our MPC protocol is structured in a preprocessing (or oﬄine) phase and an online phase. We start out in this section by presenting the online phase which assumes access to an ideal functionality FPREP . In Section 5 we show how to implement this functionality in an independent preprocessing phase.
In our speciﬁcation of the online protocol, we assume for simplicity that a broadcast channel is available at unit cost, that each party has only one input, and only one public output value is to be computed. In the full version we explain how to implement the broadcasts we need from point-to-point channels and lift the restriction on the number of inputs and outputs without this aﬀecting the overall complexity.
Before presenting the concrete online protocol we give the intuition and motivation behind the construction. We will use unconditionally secure MACs to protect secret values from being manipulated by an active adversary. However, rather than authenticating shares of secret values as in [3], we authenticate the shared value itself. More concretely, we will use a global key α chosen randomly in Fpk , and for each secret value a, we will share a additively among the players, and we also secret-share a MAC αa. This way to represent secret values is linear, just like the representation in [3], and we can therefore do secure multi-

plication based on multiplication triples `a la Beaver [2] that we produce in the preprocessing.
An immediate problem is that opening a value reliably seems to require that we check the MAC, and this requires players know α. However, as soon as α is known, MACs on other values can be forged. We solve this problem by postponing the check on the MACs (of opened values) to the output phase (of course, this may mean that some of the opened values are incorrect). During the output phase players generate a random linear combination of both the opened values and their shares of the corresponding MACs; they commit to the results and only then open α (see Figure 1). The intuition is that, because of the commitments, when α is revealed it is too late for corrupt players to exploit knowledge of the key. Therefore, if the MAC checks out, all opened values were correct with high probability, so we can trust that the output values we computed are correct and can safely open them.
Representation of values and MACs. In the online phase each shared value a ∈ Fpk is represented as follows
a := (δ, (a1, . . . , an), (γ(a)1, . . . , γ(a)n))
where a = a1 + · · · + an and γ(a)1 + · · · + γ(a)n = α(a + δ). Player Pi holds ai, γ(a)i and δ is public. The interpretation is that γ(a) ← γ(a)1 + · · · + γ(a)n is the MAC authenticating a under the global key α.
Computations. Using the natural component-wise addition of representations, and suppressing the underlying choices of ai, γ(a)i for readability, we clearly have for secret values a, b and public constant e that
a + b = a + b e · a = ea , and e + a = e + a ,
where e+ a := (δ −e, (a1 +e, a2, . . . , an), (γ(a)1, . . . , γ(a)n)). This possibility to easily add a public value is the reason for the “public modiﬁer” δ in the deﬁnition of · . It is now clear that we can do secure linear computations directly on values represented this way.
What remains is multiplications: here we use the preprocessing. We would like the preprocessing to output random triples a , b , c , where c = ab. However, our preprocessing produces triples which satisfy c = ab + ∆, where ∆ is an error that can be introduced by the adversary. We therefore need to check the triple before we use it. The check can be done by “sacriﬁcing” another triple f , g , h , where the same multiplicative equality should hold (see the protocol for details). Given such a valid triple, we can do multiplications in the following standard way: To compute xy we ﬁrst open x − a to get , and y − b to get δ. Then xy = (a + )(b + δ) = c + b + δa + δ. Thus, the new representation can be computed as
x · y = c + b + δ a + δ.

Protocol ΠOnline
Initialize: The parties ﬁrst invoke the preprocessing to get the shared secret key [[α]], a suﬃcient number of multiplication triples ( a , b , c ), and pairs of random values r , [[r]], as well as single random values [[t]], [[e]]. Then the steps below are performed in sequence according to the structure of the circuit to compute.
Input: To share Pi’s input xi, Pi takes an available pair r , [[r]]. Then, do the following: 1. [[r]] is opened to Pi (if it is known in advance that Pi will provide input, this step can be done already in the preprocessing stage). 2. Pi broadcasts ← xi − r. 3. The parties compute xi ← r + .
Add: To add two representations x , y ,the parties locally compute x + y . Multiply: To multiply x , y the parties do the following:
1. They take two triples ( a , b , c ), ( f , g , h ) from the set of the available ones and check that indeed a · b = c. – Open a representation of a random value [[t]]. – partially open t · a − f to get ρ and b − g to get σ – evaluate t · c − h − σ · f − ρ · g − σ · ρ, and partially open the result. – If the result is not zero the players abort, otherwise go on with a, b, c. Note that this check could in fact be done as part of the preprocessing. Moreover, it can be done for all triples in parallel, and so we actually need only one random value t.
2. The parties partially open x − a to get and y − b to get δ and compute z ← c + b + δ a + δ
Output: We enter this stage when the players have y for the output value y, but this value has been not been opened (the output value is only correct if players have behaved honestly). We then do the following: 1. Let a1, . . . , aT be all values publicly opened so far, where aj = (δj , (aj,1, . . . , aj,n), (γ(aj )1, . . . , γ(aj )n)). Now, a random value [[e]] is opened, and players set ei = ei for i = 1, . . . , T . All players compute a ← j ej aj . 2. Each Pi calls FCom to commit to γi ← j ejγ(aj)i. For the output value y , Pi also commits to his share yi, and his share γ(y)i in the corresponding MAC. 3. [[α]] is opened. 4. Each Pi asks FCom to open γi, and all players check that α(a + j ejδj) = i γi. If this is not OK, the protocol aborts. Otherwise the players conclude that the output value is correctly computed. 5. To get the output value y, the commitments to yi, γ(y)i are opened. Now, y is deﬁned as y := i yi and each player checks that α(y + δ) = i γ(y)i, if so, y is the output.
Fig. 1. The online phase.
An important note is that during our protocol we are actually not guaranteed that we are working with the correct results, since we do not immediately check

the MACs of the opened values. During the ﬁrst part of the protocol, parties will only do what we deﬁne as a partial opening, meaning that for a value a , each party Pi sends ai to P1, who computes a = a1 + · · · + an and broadcasts a to all players. We assume here for simplicity that we always go via P1, whereas in practice, one would balance the workload over the players.
As sketched earlier we postpone the checking to the end of the protocol in the output phase. To check the MACs we need the global key α. We get α from the preprocessing but in a slightly diﬀerent representation:
[[α]] := ((α1, . . . , αn), (βi, γ(α)i1, . . . , γ(α)in)i=1,...,n)),
where α = i αi and j γ(α)ji = αβi. Player Pi holds αi, βi, γ(α)i1, . . . , γ(α)in. The idea is that γ(α)i ← j γ(α)ji is the MAC authenticating α under Pi’s private key βi. To open [[α]] each Pj sends to each Pi his share αj of α and his share γ(α)ji of the MAC on α made with Pi’s private key and then Pi checks that j γ(α)ji = αβi. (To open the value to only one party Pi, the other parties will simply send their shares only to Pi, who will do the checking. Only shares of α and αβi are needed.)
Finally, the preprocessing will also output n pairs of a random value r in both of the presented representations r , [[r]]. These pairs are used in the Input phase of the protocol.
The full protocol for the online phase is shown in Figure 1. It assumes access to a commitment functionality FCom that simply receives values to commit to from players, stores them and reveals a value to all players on request from the committer. Such a functionality could be implemented eﬃciently based, e.g., on Paillier encryption or the DDH assumption [8, 14]. However, we show in the full version that we can do ideal commitments based only on FPREP and with cost O(n2) computation and communication.
Complexity. The (amortized) cost of a secure multiplication is easily seen to be O(n) local elementary operations in Fpk , and communication of O(n) ﬁeld elements. Linear operations have the same computational cost but require no communication. The input stage requires O(n) communication and computation to open [[r]] to Pi and one broadcast. Doing the output stage requires opening O(n) commitments. In fact, the total number of commitments used is also O(n), so this adds an O(n3) term to the complexity. In total, we therefore get the complexity claimed in the introduction: O(n·|C|+n3) elementary ﬁeld operations and storage/communication complexity O(n · |C| + n3) ﬁeld elements.
We can now state the theorem on security of the online phase, and its proof can be found in the full version.
Theorem 1. In the FPREP, FCom-hybrid model, the protocol ΠOnline implements FAMPC with statistical security against any static4 active adversary corrupting up to n − 1 parties.
4 The protocol is in fact adaptively secure, here we only show static security since our preprocessing is anyway only statically secure.

Based on a result from [18], we can also show a lower bound on the amount of preprocessing data and work required for a protocol. The proof is in the full version.
Theorem 2. Assume a protocol π is the preprocessing model can compute any circuit over Fpk of size at most S, with security against active corruption of at most n − 1 players. We assume that the players supply roughly the same number of inputs (O(S/n) each), and that any any player may receive output. Then the preprocessing must output Ω(S log pk) bits to each player, and for any player Pi, there exists a circuit C satisfying the conditions above, where secure computation of C requires Pi to execute an expected number of bit operations that is Ω(S log pk).
It is easy to see that our protocol satisﬁes the conditions in the the theorem and that it meets the ﬁrst bound up to a constant factor and the second up to a poly-logarithmic factor (as a function of the security parameter).
3 The Abstract Somewhat Homomorphic Encryption Scheme
In this section we specify the abstract properties we need for our cryptosystem. A concrete instantiation is found in Section 6.
We ﬁrst deﬁne the plaintext space M . This will be given by a direct product of ﬁnite ﬁelds (Fpk )s of characteristic p. Componentwise addition and multiplication of elements in M will be denoted by + and ·. We assume there is an injective encoding function encode which takes elements in (Fpk )s to elements in a ring R which is equal ZN (as a Z-module) for some integer N . We also assume a decode function which takes arbitrary elements in ZN and returns an element in (Fpk )s. We require that for all m ∈ M that decode(encode(m)) = m and that the decode operation is compatible with the characteristic of the ﬁeld, i.e. for any x ∈ ZN we have decode(x) = decode(x (mod p)). And ﬁnally that the encoding function produces “short” vectors. More precisely, that for all m ∈ (Fpk )s encode(m) ∞ ≤ τ where τ = p/2.
The two operations in R will be denoted by + and ·. The addition operation in R is assumed to be componentwise addition, whereas we make no assumption on multiplication. All we require is that the following properties hold, for all elements m1, m2 ∈ M ;
decode(encode(m1) + encode(m2)) = m1 + m2,
decode(encode(m1) · encode(m2)) = m1 · m2.
From now on, when we discuss the plaintext space M we assume it comes implicitly with the encode and decode functions for some integer N . If an element in M has the same component in each of the s-slots, then we call it a “diagonal” element. We let Diag(x) for x ∈ Fpk denote the element (x, x, . . . , x) ∈ (Fpk )s.
Our cryptosystem consists of a tuple (ParamGen, KeyGen, KeyGen∗, Enc, Dec) of algorithms deﬁned below, and parametrized by a security parameter κ.

ParamGen(1κ, M ): This parameter generation algorithm outputs an integer N (as above), deﬁnitions of the encode and decode functions, and a description of a randomized algorithm Ddρ, which outputs vectors in Zd. We assume that Ddρ outputs r with r ∞ ≤ ρ, except with negligible probability. The algorithm Ddρ is used by the encryption algorithm to select the random coins needed during encryption. The algorithm ParamGen also outputs an additive abelian group G. The group G also possesses a (not necessarily closed) multiplicative operator, which is commutative and distributes over the additive group of G. The group G is the group in which the ciphertexts will be assumed to lie. We write and for the operations on G, and extend these in the natural way to vectors and matrices of elements of G. Finally ParamGen outputs a set C of allowable arithmetic SIMD circuits over (Fpk )s, these are the set of functions which our scheme will be able to evaluate ciphertexts over. We can think of C as a subset of Fpk [X1, X2, . . . , Xn], where we evaluate a function f ∈ Fpk [X1, X2, . . . , Xn] a total of s times in parallel on inputs from (Fpk )n. We assume that all other algorithms take as implicit input the output P ← (1κ, N, encode, decode, Ddρ, G, C) of ParamGen. KeyGen(): This algorithm outputs a public key pk and a secret key sk. Encpk(x, r): On input of x ∈ ZN , r ∈ Zd, this deterministic algorithm outputs a ciphertext c ∈ G. When applying this algorithm one would obtain x from the application of the encode function, and r by calling Ddρ. This is what we mean when we write Encpk(m), where m ∈ M . However, it is convenient for us to deﬁne Enc on the intermediate state, x = encode(m). To ease notation we write Encpk(x) if the value of the randomness r is not important for our discussion. To make our zero-knowledge proofs below work, we will require that addition of V “clean” ciphertexts (for “small” values of V ), of plaintext xi in ZN , using randomness ri, results in a ciphertext which could be obtained by adding the plaintexts and randomness, as integer vectors, and then applying Encpk(x, r), i.e.
Encpk(x1 + · · · + xV , r1 + · · · + rV ) = Encpk(x1, r1) · · · Encpk(xV , rV ).
Decsk(c): On input the secret key and a ciphertext c it returns either an element m ∈ M , or the symbol ⊥.
We are now able to deﬁne various properties of the above abstract scheme that we will require. But ﬁrst a bit of notation: For a function f ∈ C we let n(f ) denote
the number of variables in f , and we let f denote the function on G induced by f . That is, given f , we replace every + operation with a , every · operation is replaced with a and every constant c is replaced by Encpk(encode(c), 0). Also, given a set of n(f ) vectors x1, . . . , xn(f), we deﬁne f (x1, . . . , xn(f)) in the natural way by applying f in parallel on each coordinate. Correctness: Intuitively correctness means that if one decrypts the result of a function f ∈ C applied to n(f ) encrypted vectors of variables, then this should return the same value as applying the function to the n(f ) plaintexts. However, to apply the scheme in our protocol, we need to be a bit more liberal, namely the decryption result should be correct, even if the ciphertexts we start from were not necessarily generated by the normal encryption algorithm. They

only need to “contain” encodings and randomness that are not too large, such that the encodings decode to legal values. Formally, the scheme is said to be (Bplain, Brand, C)-correct if

Pr [ P ← ParamGen(1κ, M ), (pk, sk) ← KeyGen(), for any f ∈ C, any xi, ri, with xi ∞ ≤ Bplain, ri ∞ ≤ Brand, decode(xi) ∈ (Fpk )s,

i = 1, . . . , n(f ), and ci ← Encpk(xi, ri), c ← f (c1, . . . , cn(f)) :

Decsk(c) = f (decode(x1), . . . , decode(xn(f))) ]

< (κ).

We will say that a ciphertext is (Bplain, Brand, C)-admissible if it can be obtained as the ciphertext c in the above experiment, i.e., by applying a function from C to ciphertexts generated from (legal) encodings and randomness that are bounded by Bplain and Brand. KeyGen∗(): This is a randomized algorithm that outputs a meaningless public key
pk. We require that an encryption of any message Encpk(x) is statistically indistinguishable from an encryption of 0. Furthermore, if we set (pk, sk) ← KeyGen() and pk ← KeyGen∗(), then pk and pk are computationally indistinguishable. This implies the scheme is IND-CPA secure in the usual sense.
Distributed Decryption: We assume, as a set up assumption, that a common public key has been set up where the secret key has been secret-shared among the players in such a way that they can collaborate to decrypt a ciphertext. We assume throughout that only (Bplain, Brand, C)-admissible ciphertexts are to be decrypted, this constraint is guaranteed by our main protocol.
We note that some set-up assumption is always required to show UC security which is our goal here. Concretely, we assume that a functionality FKeyGen is available, as speciﬁed in Figure 2. It basically generates a key pair and secretshares the secret key among the players using a secret-sharing scheme that is assumed to be given as part of the speciﬁcation of the cryptosystem. Since we want to allow corruption of all but one player, the maximal unqualiﬁed sets must be all sets of n − 1 players.

Functionality FKeyGen
1. When receiving “start” from all honest players, run P ← ParamGen(1κ, M ), and then, using the parameters generated, run (pk, sk) ← KeyGen() (recall P , and hence 1κ, is an implicit input to all functions we specify). Send pk to the adversary.
2. We assume a secret sharing scheme is given with which sk can be secret-shared. Receive from the adversary a set of shares sj for each corrupted player Pj.
3. Construct a complete set of shares (s1, . . . , sn) consistent with the adversary’s choices and sk. Note that this is always possible since the corrupted players form an unqualiﬁed set. Send pk to all players and si to each honest Pi.
Fig. 2. The Ideal Functionality for Distributed Key Generation

We note that it is possible to make a weaker set-up assumption, such as a common reference string (CRS), and using a general UC secure multiparty computation protocol for the CRS model to implement FKeyGen. While this may not be very eﬃcient, one only needs to run this protocol once in the life-time of the system.
We also want our cryptosystem to implement the functionality FKeyGenDec in Figure 3, which essentially speciﬁes that players can cooperate to decrypt a (Bplain, Brand, C)-admissible ciphertext, but the protocol is only secure against a passive attack: the adversary gets the correct decryption result, but can decide which result the honest players should learn.
Functionality FKeyGenDec
1. When receiving “start” from all honest players, run ParamGen(1κ, M ), and then, using the parameters generated, run (pk, sk) ← KeyGen(). Send pk to the adversary and to all players, and store sk.
2. Hereafter on receiving “decrypt c” for (Bplain, Brand, C)-admissible c from all honest players, send c and m ← Decsk(c) to the adversary. On receiving m from the adversary, send “Result m ” to all players, Both m and m may be a special symbol ⊥ indicating that decryption failed.
3. On receiving “decrypt c to Pj” for admissible c, if Pj is corrupt, send c, m ← Decsk(c) to the adversary. If Pj is honest, send c to the adversary. On receiving δ from the adversary, if δ ∈ M , send ⊥ to Pj, if δ ∈ M , send Decsk(c) + δ to Pj.
Fig. 3. The Ideal Functionality for Distributed Key Generation and Decryption
We are now ﬁnally ready to deﬁne the basic set of properties that the underlying cryptosystem should satisfy, in order to be used in our protocol. Here we use an “information theoretic” security parameter sec that controls the errors in our ZK proofs below.
Deﬁnition 1. (Admissible Cryptosystem.) Let C contain formulas of form (x1 +· · ·+xn)·(y1 +· · ·+yn)+z1 +· · ·+zn, as well as all “smaller” formulas , i.e., with a smaller number of additions and possibly no multiplication. A cryptosystem is admissible if it is deﬁned by algorithms (ParamGen, KeyGen, KeyGen∗, Enc, Dec) with properties as deﬁned above, is (Bplain, Brand, C)-correct, where
Bplain = N · τ · sec2 · 2(1/2+ν)sec, Brand = d · ρ · sec2 · 2(1/2+ν)sec;
and where ν > 0 can be an arbitrary constant. Finally there exist a secret sharing scheme as required in FKeyGen and a protocol ΠKeyGenDec with the property that when composed with FKeyGen it securely implements the functionality FKeyGenDec.
The set C is deﬁned to contain all computations on ciphertext that we need in our main protocol. Throughout the paper we will assume that Bplain, Brand are deﬁned as here in terms of τ, ρ and sec. This is because these are the bounds we can force corrupt players to respect via our zero-knowledge protocol, as we shall see.

4 Zero-Knowledge Proof of Plaintext Knowledge
This section presents a zero-knowledge protocol that takes as input sec ciphertexts c1, . . . , csec generated by one of the players in our protocol, who will act as the prover. If the prover is honest then ci = Encpk(xi, ri), where xi has been obtained from the encode function, i.e. xi ∞ ≤ τ , and ri has been generated from Ddρ (so we may assume that ri ∞ ≤ ρ). Our protocol is a zero-knowledge proof of plaintext knowledge (ZKPoPK) for the following relation:
RPoPK = { (x, w)| x = (pk, c), w = ((x1, r1), . . . , (xsec, rsec)) : c = (c1, . . . , csec), ci ← Encpk(xi, ri), xi ∞ ≤ Bplain, decode(xi) ∈ (Fpk )s, ri ∞ ≤ Brand } .
The zero-knowledge and completeness properties hold only if the ciphertexts ci satisfy xi ∞ ≤ τ and ri ∞ ≤ ρ.
In our preprocessing protocol, players will be required to give such a ZKPoPK for all ciphertexts they provide. By admissibility of the cryptosystem, this will imply that every ciphertext occurring in the protocol will be (Bplain, Brand, C)admissible and can therefore be decrypted correctly. The ZKPoPK can also be called with a ﬂag diag which will modify the proof so that it additionally proves that decode(xi) is a diagonal element.
The protocol is not meant to implement an ideal functionality, but we can still use it and prove UC security for the main protocol, since we will always generate the challenge e by calling the FRand ideal functionality (see the full version for more details).
The protocol and its proof of security are given in the full version and its computational complexity per ciphertext is essentially the cost of a constant number of encryptions. In the full version, we also give a variant of the ZK proof that allows even smaller values for Bplain, Brand, namely Bplain = N · τ · sec2 · 2sec/2+8, Brand = d · ρ · sec2 · 2sec/2+8, and hence improves performance further. This variant is most eﬃcient when executed using the Fiat-Shamir heuristic (although it can also work without random oracles), and we believe this variant is the best for a practical implementation.
5 The Preprocessing Phase
In this section we construct the protocol ΠPREP which securely implements the functionality FPREP in the presence of functionalities FKeyGenDec (Figure 3) and FRand . The preprocessing uses the above abstract cryptosystem with M = (Fpk )s, but the online phase is designed for messages in Fpk . Therefore, we extend the notation · and [[·]] to messages in M : since addition and multiplication on M are componentwise, for m = (m1, . . . , ms), we deﬁne m = ( m1 , . . . , ms ) and similarly for [[m]]. Conversely, once a representation (or a pair, triple) on vectors is produced in the preprocessing, it will be disassembled into its coordinates, so that it can be used in the online phase. In Figures 4,5 and 6, we

introduce subprotocols that are accessed by the main preprocessing protocol in several steps. Note that the subprotocols are not meant to implement ideal functionalities: their purpose is merely to summarize parts of the main protocol that are repeated in various occasions. Theorem 3 below is proved in the full version.
Theorem 3. The protocol ΠPREP (Figure 7) implements FPREP with computational security against any static, active adversary corrupting up to n−1 parties, in the FKeyGen, FRand-hybrid model when the underlying cryptosystem is admissible5.

Protocol Reshare

Usage: Input is em, where em = Encpk(m) is a public ciphertext and a parameter enc, where enc = NewCiphertext or enc = NoNewCiphertext. Output is a share

mi of m to each player Pi; and if enc = NewCiphertext, a ciphertext em. The idea is that em could be a product of two ciphertexts, which Reshare converts

to a “fresh” ciphertext em. Since Reshare uses distributed decryption (that may

return an incorrect result), it is not guaranteed that em and em contain the

same value, but it is guaranteed that i mi is the value contained in em.

Reshare(em, enc) :

1. Each Pi samples a uniform fi ∈ (Fpk )s. Deﬁne f :=

n i=1

fi.

2. Each Pi computes and broadcasts efi ← Encpk(fi).

3. Each Pi runs ΠZKPoPK as a prover on efi . The protocol aborts if any proof

fails.

4. The players compute ef ← ef1 · · · efn , and em+f ← em ef . 5. The players invoke FKeyGenDec to decrypt em+f and thereby obtain m + f . 6. P1 sets m1 ← m + f − f1, and each player Pi (i = 1) sets mi ← −fi.

7. If enc = NewCiphertext, all players set em ← Encpk(m + f ) ef1 · · · efn , where a default value for the randomness is used when computing Encpk(m + f ).

Fig. 4. The sub-protocol for additively secret sharing a plaintext m ∈ (Fpk )s on input a ciphertext em = Encpk(m).

6 Concrete Instantiation of the Abstract Scheme based on LWE
We now describe the concrete scheme, which is based on the somewhat homomorphic encryption scheme of Brakerski and Vaikuntanathan (BV) [5]. The main diﬀerences are that we are only interested in evaluation of circuits of multiplicative depth one, we are interested in performing operations in parallel on multiple data items, and we require a distributed decryption procedure. In this section we detail the scheme and the distributed decryption procedure; in the full version we discuss security of the scheme, and present some sample parameter sizes and performance ﬁgures.
5 The deﬁnition of admissible cryptosystem demands a decryption protocol that implements FKeyGenDec based on FKeyGen, hence the theorem only assumes FKeyGen.

Protocol PBracket

Usage: On input shares v1, . . . , vn privately held by the players and public cipher-

text ev, this protocol generates [[v]]. It is assumed that contained in ev. PBracket(v1, . . . , vn, ev) :

i vi is the plaintext

1. For i = 1, . . . , n

(a) All players set eγi ← eβi ev (note that eβi is generated during the initialization process, and known by every player)
(b) Players generate (γi1, . . . γin) ← Reshare(eγi , NoNewCiphertext), so each player Pj gets a share γij of v · βi.
2. Output the representation [[v]] = (v1, . . . , vn, (βi, γ1i , . . . , γni )i=1,...,n).

Fig. 5. The sub-protocol for generating [[v]].
Protocol PAngle Usage: On input shares v1, . . . , vn privately held by the players and public cipher-
text ev, this protocol generates v . It is assumed that i vi is the plaintext contained in ev. PAngle(v1, . . . , vn, ev) :
1. All players set ev·α ← ev eα (note that eα is generated during the initialization process, and known by every player)
2. Players generate (γ1, . . . , γn) ← Reshare(ev·α, NoNewCiphertext), so each player Pi gets a share γi of α · v.
3. Output representation v = (0, v1, . . . , vn, γ1, . . . , γn).

Fig. 6. The sub-protocol for generating v .

ParamGen(1κ, M ): Recall the message space is given by M = (Fpk )s for two integers k and s, and a prime p, i.e. the message space is s copies of the ﬁnite ﬁeld
Fpk . To map this to our scheme below, one ﬁrst ﬁnds a cyclotomic polynomial F (X) := Φm(X) of degree N := φ(m), where N is lower bounded by some function of the security parameter κ. The polynomial F (X) needs to be such
that modulo p the polynomial F (X) factors into l irreducible factors of degree k
where l ≥ s and k divides k . We then deﬁne an algebra Ap as Ap := Fp[X]/F (X) and we have an embedding of M into Ap, φ : M → Ap. By “lifting” modulo p we see that there is a natural inclusion ι : Ap → ZN , which maps the polynomial of degree less than N with coeﬃcients in Fp into the integer vector of length N with coeﬃcients in the range (−p/2, . . . , p/2]. The encode function is then deﬁned by ι(φ(m)) for m ∈ (Fpk )s, with decode deﬁned by φ−1(x (mod p)) for x ∈ ZN . It is clear, by choice of the natural inclusion ι, that encode(m) ∞ ≤ p/2 = τ .
We pick a large integer q, whose size we will determine later, and deﬁned
Aq := (Z/qZ)[X]/F (X), i.e. the ring of integer polynomials modulo reduction by F (X) and q. In practice we consider the image of encode to lie in Aq, and thus we abuse notation, by writing addition and multiplication in Aq by + and ·. Note, that this means that applying decode to elements obtained from encode
followed by a series of arithmetic operations may not result in the value in M
which one would expect. This corresponds to where our scheme can only evaluate
circuits from a given set C.

Protocol ΠPREP Usage: The Triple-step is always executed sec times in parallel. This ensures that

when calling ΠZKPoPK, we can always give it the sec ciphertexts it requires as input. In addition both ΠZKPoPK and ΠPREP can be executed in a SIMD fashion, i.e. they are data-oblivious bar when they detect an error. Thus we can execute ΠZKPoPK and ΠPREP on the packed plaintext space (Fpk )s. Thereby, we generate s · sec elements in one go and then buﬀer the generated triples, outputting the

next unused one on demand.

Initialize: This step generates the global key α and “personal keys” βi.

1. The players call “start” on FKeyGenDec to obtain the public key pk

2. Each Pi generates a MAC-key βi ∈ Fpk

3. Each Pi generates αi ∈ Fpk . Let α :=

n i=1

αi

4. Each Pi computes and broadcasts

eαi ← Encpk(Diag(αi)), eβi ← Encpk(Diag(βi))

5. Each Pi invokes ΠZKPoPK (with diag set to true) as prover on input

(eαi , . . . , eαi ) and on input (eβi , . . . , eβi ), where eαi , eβi are repeated sec

times, which is the number of ciphertexts ΠZKPoPK requires as input. (This

is not very eﬃcient, but only needs to be done once for each player.)

6. All players compute eα ← eα1 · · · eαn , and generate [[Diag(α)]] ← PBracket(Diag(α1), . . . , Diag(αn), eα)

Pair: This step generates a pair [[r]], r , and can be used to generate a single value

[[r]], by not performing the call to Pangle

1. Each Pi generates ri ∈ (Fpk )s. Let r :=

n i=1

ri

2. Each Pi computes and broadcasts eri ← Encpk(ri). Let er = er1 · · · ern

3. Each Pi invokes ΠZKPoPK as prover on the ciphertext he generated

4. Players generate

[[r]] ← PBracket(r1, . . . , rn, er), r ← PAngle(r1, . . . , rn, er)

Triple: This step generates a multiplicative triple a , b , c

1. Each Pi generates ai, bi ∈ (Fpk )s. Let a :=

n i=1

ai,

b

:=

n i=1

bi

2. Each Pi computes and broadcasts eai ← Encpk(ai), ebi ← Encpk(bi)

3. Each Pi invokes ΠZKPoPK as prover on the ciphertexts he generated.

4. The players set ea ← ea1 · · · ean and eb ← eb1 · · · ebn

5. Players generate

a ← PAngle(a1, . . . , an, ea), b ← PAngle(b1, . . . , bn, eb).

6. All players compute ec ← ea eb 7. Players set (c1, . . . , cn, ec) ← Reshare(ec, NewCiphertext). 8. Players generate c ← PAngle(c1, . . . , cn, ec).

Fig. 7. The protocol for constructing the global key [[α]], pairs [[r]], r and multiplicative triples a , b , c .

The ciphertext space G is deﬁned to be A3q, with addition deﬁned componentwise. The multiplicative operator is deﬁned as follows
(a0, a1, 0) (b0, b1, 0) := (a0 · b0, a1 · b0 + a0 · b1, −a1 · b1),
i.e. multiplication is only deﬁned on elements whose third coeﬃcient is zero. We deﬁne Ddρ as follows: The discrete Gaussian DZN ,s, with Gaussian param-
eter s, is deﬁned to be the random variable on ZNq (centered around the origin)

obtained from sampling x ∈ RN , with probability proportional to exp(−π · x 2/s2), and then rounding the result to the nearest lattice point and reducing it modulo q. Note, sampling from the distribution with probability density function proportional to exp(−π · x 2/s2)√, means using a normal variate with mean zero, and standard deviation r := s/ 2 · π. In our concrete scheme we set d := 3 · N and deﬁne Ddρ to be the distribution deﬁned by (DZN ,s)3. Note, that in the notation Ddρ the implicit dependence on q has been suppressed to ease readability. The determining of q and r as functions of all the other parameters, we leave until we discuss security of the scheme.
KeyGen(): We will use the public key version of the Brakerski–Vaikuntanathan scheme [5]. Given the above set up, key generation proceeds as follows: First one samples elements a ← Aq and s, e ← DZN ,s. Then treating s and e as elements of Aq one computes b ← (a · s) + (p · e). The public and private key are then set to be pk ← (a, b) and sk ← s. Encpk(x, r): Given a message x ← encode(m) where m ∈ M , and r ∈ Ddρ, we proceed as follows: The element r is parsed as (u, v, w) ∈ (ZN )3. Then the encryptor computes c0 ← (b · v) + (p · w) + x and c1 ← (a · v) + (p · u). Finally returning the ciphertext (c0, c1, 0). Decsk(c): Given a secret key sk = s and a ciphertext c = (c0, c1, c2) this algorithm computes the element in Aq satisfying t = c0 −(s·c1)−(s·s·c2). On reduction by q the value of t ∞ will be bounded by a relatively small constant B; assuming of course that the “noise” within a ciphertext has not grown too large. We shall refer to the value t mod q as the “noise”, despite it also containing the message to be decrypted. At this point the decryptor simply reduces t modulo p to obtain the desired plaintext in Aq, which can then be decoded via the decode algorithm. KeyGen∗(): This simply samples a, b ← Aq and returns pk := (a, b).
Following the discussion in [5] we see that with this ﬁxed ciphertext space, our scheme is somewhat homomorphic. It can support a relatively large number of addition operations, and a single multiplication.
Distributed Version We now extend the scheme above to enable distributed decryption. We ﬁrst set up the distributed keys as follows. After invoking the functionality for key generation, each player obtains a share ski = (si,1, si,2), these are chosen uniformly such that the master secret is written as
s = s1,1 + · · · + sn,1, s · s = s1,2 + · · · + sn,2.
As remarked earlier this one-time setup procedure can be accomplished by standard UC-secure multiparty computation protocols such as that described in [3]. The following theorem is proved in the full version. It depends on the constant B deﬁned above. In the full version we compute the value of B when the input ciphertext is (Bplain, Brand, C)-admissible, and show how to choose parameters for the cryptosystem such that the required bound on B is satisﬁed.

Theorem 4. In the FKeyGen-hybrid model, the protocol ΠDDec (Figure 8) im-
plements FKeyGenDec with statistical security against any static active adversary corrupting up to n − 1 parties if B + 2sec · B < q/2.

Protocol ΠDDec

Initialize: Each party Pi on being given the ciphertext c = (c0, c1, c2), and an upper bound B on the inﬁnity norm of t above, computes

vi ←

c0 − (si,1 · c1) − (si,2 · c2) if i = 1 −(si,1 · c1) − (si,2 · c2) if i = 1

and sets ti ← vi + p · ri where ri is a random element with inﬁnity norm bounded by 2sec · B/(n · p). Public Decryption: All the players are supposed to learn the message.
– Each party Pi broadcasts ti – All players compute t ← t1 + · · · + tn and obtain a message m ←
decode(t mod p). Private Decryption: Only player Pj is supposed to learn the message.
– Each party Pi sends ti to Pj – Pj computes t ← t1 + · · · + tn and obtain a message m ← decode(t mod
p).

Fig. 8. The distributed decryption protocol.

7 Acknowledgements
The ﬁrst, second and fourth author acknowledge support from the Danish National Research Foundation and The National Science Foundation of China (under the grant 61061130540) for the Sino-Danish Center for the Theory of Interactive Computation, within which [part of] this work was performed; and also from the CFEM research center (supported by the Danish Strategic Research Council) within which part of this work was performed.
The third author was supported by the European Commission through the ICT Programme under Contract ICT-2007-216676 ECRYPT II and via an ERC Advanced Grant ERC-2010-AdG-267188-CRIPTO, by EPSRC via grant COED– EP/I03126X, the Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL) under agreement number FA875011-2-0079, and by a Royal Society Wolfson Merit Award. The US Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation hereon. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the oﬃcial policies or endorsements, either expressed or implied, of DARPA, AFRL, the U.S. Government, the European Commission or EPSRC.
The authors would like to thank Robin Chapman, Henri Cohen and Rob Harley for various discussions whilst this work was carried out.

References
1. G. Asharov, A. Jain, A. Lo´pez-Alt, E. Tromer, V. Vaikuntanathan, and D. Wichs. Multiparty computation with low communication, computation and interaction via threshold fhe. In D. Pointcheval and T. Johansson, editors, EUROCRYPT, volume 7237 of Lecture Notes in Computer Science, pages 483–501. Springer, 2012.
2. D. Beaver. Eﬃcient multiparty protocols using circuit randomization. In J. Feigenbaum, editor, CRYPTO, volume 576 of Lecture Notes in Computer Science, pages 420–432. Springer, 1991.
3. R. Bendlin, I. Damg˚ard, C. Orlandi, and S. Zakarias. Semi-homomorphic encryption and multiparty computation. In EUROCRYPT, pages 169–188, 2011.
4. Z. Brakerski, C. Gentry, and V. Vaikuntanathan. Fully homomorphic encryption without bootstrapping. Electronic Colloquium on Computational Complexity (ECCC), 18:111, 2011.
5. Z. Brakerski and V. Vaikuntanathan. Fully homomorphic encryption from ring-lwe and security for key dependent messages. In P. Rogaway, editor, CRYPTO, volume 6841 of Lecture Notes in Computer Science, pages 505–524. Springer, 2011.
6. R. Canetti, Y. Lindell, R. Ostrovsky, and A. Sahai. Universally composable twoparty and multi-party secure computation. In STOC, pages 494–503, 2002.
7. I. Damg˚ard, M. Keller, E. Larraia, C. Miles, and N. P. Smart. Implementing aes via an actively/covertly secure dishonest-majority mpc protocol. IACR Cryptology ePrint Archive, 2012:262, 2012.
8. I. Damg˚ard and J. B. Nielsen. Perfect hiding and perfect binding universally composable commitment schemes with constant expansion factor. In M. Yung, editor, CRYPTO, volume 2442 of Lecture Notes in Computer Science, pages 581– 596. Springer, 2002.
9. I. Damg˚ard and C. Orlandi. Multiparty computation for dishonest majority: From passive to active security at low cost. In CRYPTO, pages 558–576, 2010.
10. C. Gentry. Fully homomorphic encryption using ideal lattices. In M. Mitzenmacher, editor, STOC, pages 169–178. ACM, 2009.
11. C. Gentry, S. Halevi, and N. P. Smart. Fully homomorphic encryption with polylog overhead. In D. Pointcheval and T. Johansson, editors, EUROCRYPT, volume 7237 of Lecture Notes in Computer Science, pages 465–482. Springer, 2012.
12. Y. Ishai, E. Kushilevitz, R. Ostrovsky, and A. Sahai. Zero-knowledge from secure multiparty computation. In D. S. Johnson and U. Feige, editors, STOC, pages 21–30. ACM, 2007.
13. Y. Ishai, M. Prabhakaran, and A. Sahai. Founding cryptography on oblivious transfer - eﬃciently. In D. Wagner, editor, CRYPTO, volume 5157 of Lecture Notes in Computer Science, pages 572–591. Springer, 2008.
14. Y. Lindell. Highly-eﬃcient universally-composable commitments based on the ddh assumption. In EUROCRYPT, pages 446–466, 2011.
15. S. Myers, M. Sergi, and abhi shelat. Threshold fully homomorphic encryption and secure computation. IACR Cryptology ePrint Archive, 2011:454, 2011.
16. J. B. Nielsen, P. S. Nordholt, C. Orlandi, and S. S. Burra. A new approach to practical active-secure two-party computation. IACR Cryptology ePrint Archive, 2011:91, 2011.
17. N. P. Smart and F. Vercauteren. Fully homomorphic simd operations. IACR Cryptology ePrint Archive, 2011:133, 2011.
18. S. Winkler and J. Wullschleger. On the eﬃciency of classical and quantum oblivious transfer reductions. In CRYPTO, pages 707–723, 2010.

